# 多宫格抽奖逻辑改进

## 🔍 用户发现的问题

### 问题1：允许重复时的分布逻辑不合理
**用户观察：**
- 7个项目，9宫格，允许重复
- 前7个宫格中有2个重复的名字
- 后2个宫格中有1个在前面出现过的名字

**用户期望：**
- 前7个宫格应该是唯一的（每个项目一次）
- 后2个宫格从7个项目中选择2个来填补

### 问题2：再次抽奖时宫格不重新洗牌
**用户观察：**
- 点击"再抽一次"后，9宫格中的名字顺序没有变化
- 还是上一次抽奖的布局

**用户期望：**
- 每次抽奖都应该重新洗牌，产生不同的布局

## 🤔 问题分析

### 问题1的根本原因
原来的算法：
```typescript
// 1. 先放入所有项目
filledItems.push(...items)  // 7个项目

// 2. 随机填充剩余位置
for (let i = 0; i < remainingSlots; i++) {
  filledItems.push(items[randomIndex])  // 2个随机项目
}

// 3. 全局随机打乱
return filledItems.sort(() => Math.random() - 0.5)
```

**问题：**
- 最后的全局打乱导致原本唯一的7个项目可能聚集在一起
- 用户看到的分布不符合直觉

### 问题2的根本原因
`handleDrawAgain` 函数只重置了状态，没有重新初始化宫格：
```typescript
// 只是重置状态，没有重新洗牌
setGameState(prev => ({
  ...prev,
  phase: 'idle',
  cells: prev.cells.map(cell => ({  // 使用原来的cells
    ...cell,
    isHighlighted: false,
    isWinner: false
  }))
}))
```

## ✅ 改进方案

### 改进1：优化分布算法

**新算法思路：**
1. 计算每个项目的基础出现次数
2. 平均分配额外的位置
3. 随机打乱最终布局

```typescript
// 计算每个项目应该出现的基础次数
const baseCount = Math.floor(gridSize / items.length)  // 9/7 = 1
const extraCount = gridSize % items.length            // 9%7 = 2

// 为每个项目分配基础出现次数
items.forEach(item => {
  for (let i = 0; i < baseCount; i++) {
    filledItems.push(item)  // 每个项目至少1次
  }
})

// 随机选择项目来填充剩余的位置
const shuffledItems = [...items].sort(() => Math.random() - 0.5)
for (let i = 0; i < extraCount; i++) {
  filledItems.push(shuffledItems[i])  // 随机2个项目额外出现1次
}

// 随机打乱所有项目的位置
return filledItems.sort(() => Math.random() - 0.5)
```

**改进效果：**
- 7个项目，9宫格：每个项目至少出现1次，随机2个项目额外出现1次
- 分布更加均匀和公平
- 符合数学期望：每个项目期望出现 9/7 ≈ 1.29 次

### 改进2：修复再次抽奖的重新洗牌

```typescript
const handleDrawAgain = () => {
  // ... 清理定时器和音效 ...
  
  // 重新初始化宫格布局（重新洗牌）
  if (config) {
    initializeGrid(config)  // 重新调用初始化函数
  }
  
  // 重置状态（不再手动设置cells）
  setShowResult(false)
  setGameState(prev => ({
    ...prev,
    phase: 'idle',
    currentHighlight: -1,
    winner: null,
    countdown: 3
  }))
}
```

**改进效果：**
- 每次点击"再抽一次"都会重新洗牌
- 产生不同的宫格布局
- 增加抽奖的随机性和趣味性

## 📊 改进效果对比

### 7个项目，9宫格的分布

**改进前（可能的问题分布）：**
```
项目1: 2次 | 项目2: 2次 | 项目3: 1次 | 项目4: 1次
项目5: 1次 | 项目6: 1次 | 项目7: 1次
```
- 不均匀，前面的项目可能获得更多机会

**改进后（更均匀的分布）：**
```
每个项目: 至少1次，随机2个项目额外+1次
期望分布: 5个项目1次，2个项目2次（随机选择）
```
- 更公平，符合数学期望

### 再次抽奖的体验

**改进前：**
- 宫格布局固定不变
- 用户可能怀疑抽奖的随机性

**改进后：**
- 每次都重新洗牌
- 增加抽奖的新鲜感和可信度

## 🎯 数学验证

### 公平性验证
对于 n 个项目填充 m 个宫格（n < m）：

**新算法保证：**
- 每个项目至少出现 ⌊m/n⌋ 次
- 随机 (m % n) 个项目额外出现 1 次
- 每个项目的期望出现次数：m/n

**7个项目，9宫格的例子：**
- 每个项目至少出现 ⌊9/7⌋ = 1 次
- 随机 (9 % 7) = 2 个项目额外出现 1 次
- 每个项目期望出现次数：9/7 ≈ 1.29 次

### 随机性验证
- 额外位置的分配是随机的
- 最终位置的排列是随机的
- 每次抽奖的布局都不同

## 🎮 用户体验改进

1. **更直观的分布**：符合用户对"允许重复"的理解
2. **更公平的概率**：数学上更加均匀
3. **更好的随机性**：每次抽奖都有新的布局
4. **更高的可信度**：用户能感受到真正的随机性

## 总结

这两个改进解决了用户发现的核心问题：
- ✅ **分布逻辑**：更均匀、更公平的项目分配
- ✅ **重新洗牌**：每次抽奖都产生新的布局
- ✅ **用户体验**：符合直觉，增加信任度
- ✅ **数学正确性**：保持概率的公平性

现在多宫格抽奖在"允许重复"模式下既公平又符合用户期望！